module Discussions
  class CommitWithUnresolvedDiscussionsService < Discussions::BaseService
    COMMENTERS = {
      double_slash: lambda { |l| "// #{l}" },
      pound:        lambda { |l| "# #{l}" },
      xml:          lambda { |l| l.sub(/.*/, '<!-- \0 -->') }
    }.freeze

    COMMENT_TYPES_BY_LANG = {
      default: :double_slash,

      php: :double_slash,
      javascript: :double_slash,
      c: :double_slash,

      markdown: :xml,
      html: :xml,
      xml: :xml,

      ruby: :pound,
      yaml: :pound
    }.freeze

    def execute(merge_request)
      @merge_request = merge_request

      commit_sha = repository.multi_action(
        user: @merge_request.author,
        branch_name: nil, # We just want a commit, not a branch
        message: commit_message,
        start_branch_name: @merge_request.source_branch,
        start_project: @merge_request.source_project,
        actions: update_actions
      )
      return unless commit_sha

      project.commit(commit_sha)
    end

    private

    def discussions
      @discussions ||= begin
        notes = @merge_request.
          notes.
          diff_notes.
          fresh.
          inc_relations_for_view

        Discussion.build_collection(notes, @merge_request).select(&:expanded?)
      end
    end

    def insertions_by_path
      discussions.map do |discussion|
        position = discussion.position
        next if !position || position.removed?

        OpenStruct.new(
          path: position.file_path,
          line: position.new_line,
          text: text_for_discussion(discussion)
        )
      end.compact.group_by(&:path)
    end

    def update_actions
      insertions_by_path.map do |path, insertions|
        {
          action: :update,
          file_path: path,
          content: content_for_path(path, insertions)
        }
      end
    end

    def content_for_path(path, insertions)
      blob = repository.blob_at(@merge_request.diff_head_sha, path)
      blob.load_all_data!(repository)

      commenter = commenter_for_blob(blob)

      content = blob.data.dup
      content << "\n" unless content.end_with?("\n")
      lines = content.lines

      line_offset = 0
      insertions.sort_by(&:line).each do |insertion|
        text = insertion.text
        text << "\n" unless text.end_with?("\n")

        text = text.lines.map(&commenter).join

        insertion_lines = text.lines

        line_index = insertion.line + line_offset

        preceding_line_index = line_index - 1
        if preceding_line_index >= 0
          preceding_line = lines[preceding_line_index]
          insertion_lines = indent_lines_based_on_preceding_line(insertion_lines, preceding_line)
        end

        lines.insert(line_index, *insertion_lines)
        line_offset += insertion_lines.length
      end

      lines.join
    end

    def commenter_for_blob(blob)
      lexer = Gitlab::Highlight.new(blob.name, blob.data, repository: repository).lexer
      lang = lexer.tag.to_sym
      comment_type = COMMENT_TYPES_BY_LANG[lang] || COMMENT_TYPES_BY_LANG[:default]
      COMMENTERS[comment_type]
    end

    def indent_lines_based_on_preceding_line(lines, preceding_line)
      indentation = preceding_line.match(/\A\s*/)[0]
      return lines unless indentation && indentation.length > 0

      lines.map { |line| "#{indentation}#{line}" }
    end

    def commit_message
      <<-MSG.strip_heredoc
        FIXME: Add code comments for unresolved discussions from #{@merge_request.to_reference(full: true)}

        All unresolved non-outdated diff discussions from this merge request are
        added in the relevant places as code comments with a 'FIXME' prefix.

        This commit was automatically generated by GitLab. Be sure to remove it
        from your branch before the merge request is merged.
      MSG
    end

    def text_for_discussion(discussion)
      discussion.notes.map.with_index { |note, i| text_for_note(note, i) }.join("\n\n")
    end

    def text_for_note(note, i)
      byline = "FIXME: #{note.author.name} (#{note.author.to_reference}) "
      byline << (i == 0 ? "started a discussion on the previous line:" : "commented:")
      byline << " (Resolved by #{note.resolved_by.try(:name)})" if note.resolved?
      comment = note.note.lines.map { |l| "  #{l}" }.join

      [byline, comment].join("\n")
    end
  end
end
